package adl

import (
	"github.com/golangee/architecture/arc/token"
	"runtime"
)

// A Project has multiple modules, like libraries, servers or clients, frontends or backends.
type Project struct {
	Name     token.String
	Modules  []*Module
	Glossary *Glossary
}

func NewProject(name string) *Project {
	return &Project{
		Name: traceStr(name),
	}
}

func (w *Project) PutGlossary(key, val string) *Project {
	if w.Glossary == nil {
		w.Glossary = NewGlossary()
	}

	w.Glossary.Terms[key] = Term{
		Ident:       traceStr(key),
		Description: traceStr(val),
	}

	return w
}

func (w *Project) AddModules(p ...*Module) *Project {
	w.Modules = append(w.Modules, p...)
	return w
}

// An Executable defines an entry point into the application. At least Java and Go support an arbitrary set of
// main entry points.
type Executable struct {
	Comment token.String
	Name    token.String
}

func NewExecutable(name, comment string) *Executable {
	return &Executable{
		Name:    traceStr(name),
		Comment: traceStr(comment),
	}
}

// A Module is e.g. a server application, a frontend or a shared library.
type Module struct {
	Preamble    Preamble
	Name        token.String // the name of the project
	Generator   *Generator
	Domain      *Domain
	Executables []*Executable
}

func NewModule(name string) *Module {
	return &Module{
		Name: traceStr(name),
		Preamble: Preamble{
			Generator: "Code generated by golangee/eearc; DO NOT EDIT.",
		},
	}
}

func (p *Module) AddExecutables(e ...*Executable) *Module {
	p.Executables = append(p.Executables, e...)
	return p
}

func (p *Module) SetLicense(str string) *Module {
	p.Preamble.License = str
	return p
}

func (p *Module) SetGenerator(g *Generator) *Module {
	p.Generator = g
	return p
}

func (p *Module) SetDomain(d *Domain) *Module {
	p.Domain = d
	return p
}

// A Generator describes how this project should be generated.
type Generator struct {
	Go     *Golang
	OutDir token.String // the target directory to (re) write the module
}

func NewGenerator() *Generator {
	return &Generator{}
}

func (g *Generator) SetGo(d *Golang) *Generator {
	g.Go = d
	return g
}

func (g *Generator) SetOutDir(dir string) *Generator {
	g.OutDir = traceStr(dir)
	return g
}

// Golang describes how a Go project (or module) must be created or updated.
type Golang struct {
	Module   token.String   // the name of the go module, e.g. github.com/worldiety/supportiety
	Requires []token.String // require directives
}

func NewGolang() *Golang {
	return &Golang{}
}

func (g *Golang) SetModName(name string) *Golang {
	g.Module = traceStr(name)
	return g
}

func (g *Golang) Require(dep string) *Golang {
	g.Requires = append(g.Requires, traceStr(dep))
	return g
}

// A BoundedContext is a cross-cutting thing, which is referenced from various places and contains its own
// ubiquitous language (== glossary).
type BoundedContext struct {
	Name token.String
}

type Domain struct {
	Name    token.String
	Core    []*Package // multiple core packages are allowed, to allow arbitrary large and complex nested (sub or supporting) domains.
	Usecase []*Package // same for the use cases
}

func NewDomain(name string) *Domain {
	return &Domain{
		Name: traceStr(name),
	}
}

func (d *Domain) AddCore(l ...*Package) *Domain {
	d.Core = append(d.Core, l...)
	return d
}

func (d *Domain) AddUsecase(l *Package) *Domain {
	d.Usecase = append(d.Usecase, l)
	return d
}

type Package struct {
	Comment      token.String
	Name         token.String
	Repositories []*Interface
	Services     []*Service
	DTOs         []*DTO
}

func NewPackage(name, comment string) *Package {
	return &Package{Name: traceStr(name), Comment: traceStr(comment)}
}

func (p *Package) AddRepositories(r ...*Interface) *Package {
	p.Repositories = append(p.Repositories, r...)
	return p
}

func (p *Package) AddDataTransferObjects(d ...*DTO) *Package {
	p.DTOs = append(p.DTOs, d...)
	return p
}

func (p *Package) AddServices(s ...*Service) *Package {
	p.Services = append(p.Services, s...)
	return p
}

type Interface struct {
	Comment token.String
	Name    token.String
	Methods []*Method
}

func NewInterface(name, comment string) *Interface {
	return &Interface{
		Comment: traceStr(comment),
		Name:    traceStr(name),
	}
}

func (i *Interface) AddMethods(m ...*Method) *Interface {
	i.Methods = append(i.Methods, m...)
	return i
}

type Service struct {
	Comment token.String
	Name    token.String
	Fields  []*Field
	Methods []*Method
}

func NewService(name, comment string) *Service {
	return &Service{
		Comment: traceStr(comment),
		Name:    traceStr(name),
	}
}

type DTO struct {
	Comment token.String
	Name    token.String
	Fields  []*Field
}

func NewDTO(name, comment string) *DTO {
	return &DTO{
		Comment: traceStr(comment),
		Name:    traceStr(name),
	}
}

func (d *DTO) AddField(name, comment string, decl *TypeDecl) *DTO {
	d.Fields = append(d.Fields, &Field{
		Comment: traceStr(comment),
		Name:    traceStr(name),
		Type:    decl,
	})

	return d
}

type Field struct {
	Comment token.String
	Name    token.String
	Type    *TypeDecl
}

type Method struct {
	Comment token.String
	Name    token.String
	In      []*Param
	Out     []*Param
}

func NewMethod(name, comment string) *Method {
	return &Method{
		Comment: traceStr(comment),
		Name:    traceStr(name),
	}
}

func (m *Method) AddIn(name, comment string, decl *TypeDecl) *Method {
	m.In = append(m.In, &Param{
		Name:    traceStr(name),
		Comment: traceStr(comment),
		Type:    decl,
	})

	return m
}

func (m *Method) AddOut(name, comment string, decl *TypeDecl) *Method {
	m.Out = append(m.Out, &Param{
		Name:    traceStr(name),
		Comment: traceStr(comment),
		Type:    decl,
	})

	return m
}

func (m *Method) OutParams(p ...*Param) *Method {
	m.In = p
	return m
}

type Param struct {
	Comment token.String
	Name    token.String
	Type    *TypeDecl
}

func traceStr(v string) token.String {
	_, file, line, _ := runtime.Caller(2)
	str := token.NewString(v)
	str.BeginPos.File = file
	str.BeginPos.Line = line
	str.BeginPos.Col = 1
	str.BeginPos.Offset = -1

	str.EndPos = str.BeginPos
	str.EndPos.Col += len(v)

	return str
}

type Term struct {
	Ident       token.String
	Description token.String
}

type Glossary struct {
	Terms map[string]Term
}

func NewGlossary() *Glossary {
	return &Glossary{
		Terms: map[string]Term{},
	}
}

func (g *Glossary) Put(key, val string) *Glossary {
	if g.Terms == nil {
		g.Terms = map[string]Term{}
	}

	g.Terms[key] = Term{
		Ident:       traceStr(key),
		Description: traceStr(val),
	}

	return g
}

type Preamble struct {
	Generator string
	License   string
}

// A TypeDecl is the generified declaration of named types, consisting of full qualified name, a pointer flag
// and optionally nested other type parameters.
type TypeDecl struct {
	Name       token.String
	TypeParams []*TypeDecl
}

func NewTypeDecl(name string, typeDecl ...*TypeDecl) *TypeDecl {
	return &TypeDecl{
		Name:       traceStr(name),
		TypeParams: typeDecl,
	}
}

// IsPtr checks for * and expects exactly 1 TypeParam.
func (t *TypeDecl) IsPtr() bool {
	return t.Name.String() == "*" && len(t.TypeParams) == 1
}

// IsSlice checks for [] and expects exactly 1 TypeParam.
func (t *TypeDecl) IsSlice() bool {
	return t.Name.String() == "[]" && len(t.TypeParams) == 1
}

// IsArray checks for [] and expects exactly 2 TypeParams (first is len, second the actual type).
func (t *TypeDecl) IsArray() bool {
	return t.Name.String() == "[]" && len(t.TypeParams) == 2
}

// IsMap checks for map! and expects exactly 2 TypeParams.
func (t *TypeDecl) IsMap() bool {
	return t.Name.String() == "map!" && len(t.TypeParams) == 2
}
