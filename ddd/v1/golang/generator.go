package golang

import (
	"fmt"
	"github.com/golangee/architecture/ddd/v1"
	"github.com/golangee/architecture/ddd/v1/validation"
	"github.com/golangee/reflectplus/mod"
	"log"
	"os"
	"time"
)

type generator struct {
	opts   Options
	spec   *ddd.AppSpec
	server mod.Modules
	client mod.Modules
	arch   mod.Modules
}

func newGenerator(opts Options, spec *ddd.AppSpec) *generator {
	return &generator{
		opts: opts,
		spec: spec,
	}
}

func (g *generator) make() error {
	start := time.Now()
	defer func() {
		log.Printf("make: needed %v\n", time.Now().Sub(start))
	}()

	if err := g.loadTargetModules(); err != nil {
		return err
	}

	if err := validation.Validate(g.spec); err != nil {
		return fmt.Errorf("validation failed: %w", err)
	}

	if !g.opts.DoNotClean {
		if err := g.clean(); err != nil {
			return err
		}
	}

	gctx := &genctx{
		mod:     g.server,
		spec:    g.spec,
		archMod: g.arch,
	}

	if err := generateCmdSrv(gctx); err != nil {
		return err
	}

	if err := generateLayers(gctx); err != nil {
		return err
	}

	// generateLayer has collected a bunch of stuff, which we need to create the actual app
	if err := generateApp(gctx); err != nil {
		return err
	}

	if err := gctx.emit(); err != nil {
		return err
	}

	return nil
}

// clean is quite clever and removes every file which has ever been generated by us. Afterwards it removes
// all empty folders and continues as long as no more folders can be deleted.
func (g *generator) clean() error {
	var allCandidates []string
	files, err := findMyFiles(g.server.Main().Dir)
	if err != nil {
		return err
	}

	allCandidates = append(allCandidates, files...)

	files, err = findMyFiles(g.client.Main().Dir)
	if err != nil {
		return err
	}

	allCandidates = append(allCandidates, files...)

	for _, candidate := range allCandidates {
		log.Printf("remove: %s\n", candidate)
		if err := os.Remove(candidate); err != nil {
			return fmt.Errorf("cannot remove '%s': %w", candidate, err)
		}
	}

	for true {
		folderCount := make(map[string]int)
		if err := countFiles(g.client.Main().Dir, folderCount); err != nil {
			return err
		}

		if err := countFiles(g.server.Main().Dir, folderCount); err != nil {
			return err
		}

		needAnotherRun := false
		for path, count := range folderCount {
			if count == 0 {
				needAnotherRun = true
				log.Printf("remove: %s\n", path)
				if err := os.RemoveAll(path); err != nil {
					return err
				}
			}
		}

		if !needAnotherRun {
			break
		}
	}

	return nil
}
