// Code generated by golangee/architecture. DO NOT EDIT.

package mysql

import (
	context "context"
	sql "database/sql"
	json "encoding/json"
	fmt "fmt"
	time "time"
)

// migration represents a single isolated database migration, which may consist of multiple statements but which must be executed atomically.
type migration struct {
	// Version is the unix timestamp in seconds, at which this migration was defined.
	Version int64
	// Description describes at least why the migration is needed.
	Description string
	// Statements contains e.g. CREATE, ALTER or DROP statements to apply.
	Statements []string
	// File is the file path indicating the origin of the statements.
	File string
	// Line is the line number indicating the origin of the statements.
	Line int32
	// Checksum is the hex encoded first 16 byte sha3-256 checksum of all trimmed statements.
	Checksum string
}

// String serializes the struct into a json string.
func (m migration) String() string {
	buf, err := json.Marshal(m)
	if err != nil {
		panic("invalid state: " + err.Error())
	}

	return string(buf)
}

// Apply executes the statements.
func (m migration) Apply(db DBTX) error {
	for _, s := range m.Statements {
		_, err := db.ExecContext(context.Background(), s)
		if err != nil {
			return fmt.Errorf("cannot ExecContext: %w", err)
		}
	}
	return nil
}

// migrationEntry represents a row entry from the migration schema history table.
type migrationEntry struct {
	// Version is the unix timestamp in seconds, at which this migration was defined.
	Version int64
	// File is the file path indicating the origin of the statements.
	File string
	// Line is the line number indicating the origin of the statements.
	Line int32
	// Checksum is the hex encoded first 16 byte sha3-256 checksum of all trimmed statements.
	Checksum string
	// AppliedAt is the unix timestamp in seconds when this migration has been applied.
	AppliedAt int64
	// ExecutionDuration is the amount of nanoseconds which were needed to apply this migration.
	ExecutionDuration int64
	// Description describes at least why the migration is needed.
	Description string
	// Status is the status of the migration
	Status string
}

// String serializes the struct into a json string.
func (m migrationEntry) String() string {
	buf, err := json.Marshal(m)
	if err != nil {
		panic("invalid state: " + err.Error())
	}

	return string(buf)
}

// insert writes a migrationEntry into the history table.
func (m migrationEntry) insert(db DBTX) error {
	const q = "INSERT INTO search_migration_schema_history(version, file, line, checksum, applied_at, execution_duration, description, status) VALUES (?, ?, ?, ?, ?, ?, ?, ?)"
	_, err := db.ExecContext(context.Background(), q, m.Version, m.File, m.Line, m.Checksum, m.AppliedAt, m.ExecutionDuration, m.Description, m.Status)
	if err != nil {
		return fmt.Errorf("cannot ExecContext: %w", err)
	}

	return nil
}

// update writes a migrationEntry into the history table and replaces the exiting entry identified by version.
func (m migrationEntry) update(db DBTX) error {
	const q = "UPDATE search_migration_schema_history SET file = ?, line = ?, checksum = ?, applied_at = ?, execution_duration = ?, description = ?, status = ? WHERE version = ?"
	_, err := db.ExecContext(context.Background(), q, m.File, m.Line, m.Checksum, m.AppliedAt, m.ExecutionDuration, m.Description, m.Status, m.Version)
	if err != nil {
		return fmt.Errorf("cannot ExecContext: %w", err)
	}

	return nil
}

// readMigrationHistoryTable reads the entire history into memory, which are only a few bytes.
func readMigrationHistoryTable(db DBTX) ([]migrationEntry, error) {
	var res []migrationEntry
	rows, err := db.QueryContext(context.Background(), "SELECT version, file, line, checksum, applied_at, execution_duration, description, status FROM search_migration_schema_history ORDER BY version ASC")
	if err != nil {
		return nil, fmt.Errorf("cannot query history: %w", err)
	}
	defer rows.Close()
	for rows.Next() {
		var i migrationEntry
		if err := rows.Scan(&i.Version, &i.File, &i.Line, &i.Checksum, &i.AppliedAt, &i.ExecutionDuration, &i.Description, &i.Status); err != nil {
			return nil, fmt.Errorf("scan failed: %w", err)
		}
		res = append(res, i)
	}
	err = rows.Close()
	if err != nil {
		return res, fmt.Errorf("cannot close rows: %w", err)
	}

	err = rows.Err()
	if err != nil {
		return res, fmt.Errorf("query failed: %w", err)
	}

	return res, nil
}

// Migrate ensures that the migration history table exists, checks the checksums of all already applied migrations
// and applies all missing migrations in the defined version order.
func Migrate(db DBTX) error {

	// if we can start a transaction on our own, do so and invoke recursively
	if db, ok := db.(*sql.DB); ok {
		tx, err := db.BeginTx(context.Background(), nil)
		if err != nil {
			return fmt.Errorf("cannot begin transaction: %w", err)
		}

		if err := Migrate(tx); err != nil {
			if suppressedErr := tx.Rollback(); suppressedErr != nil {
				fmt.Println(suppressedErr.Error())
			}
			return err
		}

		if err := tx.Commit(); err != nil {
			return err
		}

		return nil
	}

	const q = `CREATE TABLE IF NOT EXISTS "search_migration_schema_history"
(
    "version"            BIGINT       NOT NULL,
    "file"               VARCHAR(255) NOT NULL,
    "line"               INT          NOT NULL,
    "checksum"           CHAR(32)     NOT NULL,
    "applied_at"         BIGINT       NOT NULL,
    "execution_duration" BIGINT       NOT NULL,
	"description"		 TEXT         NOT NULL,
	"status"			 VARCHAR(255) NOT NULL,
    PRIMARY KEY ("version")
)`
	if _, err := db.ExecContext(context.Background(), q); err != nil {
		return fmt.Errorf("cannot create search_migration_schema_history: %w", err)
	}

	history, err := readMigrationHistoryTable(db)
	if err != nil {
		return fmt.Errorf("cannot read history: %w", err)
	}

	availMigrations := migrations()

	// check history validity:
	// 1. is everything which has been applied still defined?
	// 2. has any checksum changed?
	// 3. do we have any unclean migration?
	for _, entry := range history {
		found := false
		for _, m := range availMigrations {
			if entry.Status != "success" {
				return fmt.Errorf("found an incomplete migration. Your database is inconsistent and you have to solve this manually. Affected migration: %s", entry.String())
			}

			if entry.Version == m.Version {
				if entry.Checksum != m.Checksum {
					return fmt.Errorf("already applied migration %s has been modified. Expected %s but found %s", entry.String(), entry.Checksum, m.Checksum)
				}

				found = true
				break
			}

		}

		if !found {
			return fmt.Errorf("already applied migration %s is undefined", entry.String())
		}
	}

	// pick migrations to apply
	for _, m := range availMigrations {
		alreadyApplied := false
		for _, entry := range history {
			if m.Version == entry.Version {
				alreadyApplied = true
				break
			}
		}

		if !alreadyApplied {
			start := time.Now()

			entry := migrationEntry{
				Version:     m.Version,
				File:        m.File,
				Line:        m.Line,
				Checksum:    m.Checksum,
				AppliedAt:   start.Unix(),
				Description: m.Description,
				Status:      "pending",
			}
			err = entry.insert(db)
			if err != nil {
				return fmt.Errorf("unable to insert migration state %s: %w", m.String(), err)
			}

			err := m.Apply(db)
			if err != nil {
				return fmt.Errorf("unable to apply migration %s: %w", m.String(), err)
			}

			entry.ExecutionDuration = time.Now().Sub(start).Nanoseconds()
			entry.Status = "success"
			err = entry.update(db)
			if err != nil {
				return fmt.Errorf("unable to update migration state %s: %w", m.String(), err)
			}
		}
	}

	return nil
}

// migrations returns all available migrations in sorted order from oldest to latest.
func migrations() []migration {
	return []migration{
		{
			Version:     1600256820, // 2020-09-16T11:47:00
			File:        "architecture.go",
			Line:        108,
			Checksum:    "d961978f6bd240de8d5c0588c47733b2",
			Description: "Creates the initial schema.",
			Statements: []string{
				"CREATE TABLE book (`id` BINARY(16), name VARCHAR(255))",
				"CREATE TABLE book3 (id BINARY(16))",
				"CREATE TABLE book3 (id JSON)",
				"SELECT blub from BLA",
				"INSERT INTO book3 VALUES(1,2)",
				"ALTER TABLE BLA ADD COLUMN (id TEXT)",
			},
		},
		{
			Version:     1600343220, // 2020-09-17T11:47:00
			File:        "architecture.go",
			Line:        117,
			Checksum:    "b520b7ccb7c9117078f00ad3373070f5",
			Description: "Adding another table to support other books.",
			Statements: []string{
				"CREATE TABLE book5 (id BINARY(16), name VARCHAR(255))",
			},
		},
	}
}
