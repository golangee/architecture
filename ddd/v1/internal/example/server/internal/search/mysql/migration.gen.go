// Code generated by golangee/architecture. DO NOT EDIT.

package mysql

import (
	context "context"
	sql "database/sql"
	json "encoding/json"
	fmt "fmt"
	time "time"
)

// migration represents a single isolated database migration, which may consist of multiple statements but which must be executed atomically.
type migration struct {
	// Version is the unix timestamp in seconds, at which this migration was defined.
	Version int64
	// Statements contains e.g. CREATE, ALTER or DROP statements to apply.
	Statements []string
	// File is the file path indicating the origin of the statements.
	File string
	// Line is the line number indicating the origin of the statements.
	Line int32
	// Checksum is the hex encoded first 16 byte sha3-256 checksum of all trimmed statements.
	Checksum string
}

// String serializes the struct into a json string.
func (m migration) String() string {
	buf, err := json.Marshal(m)
	if err != nil {
		panic("invalid state: " + err.Error())
	}

	return string(buf)
}

// Apply executes the statements.
func (m migration) Apply(db DBTX) error {
	for _, s := range m.Statements {
		_, err := db.ExecContext(context.Background(), s)
		if err != nil {
			return fmt.Errorf("cannot ExecContext: %w", err)
		}
	}
	return nil
}

// migrationEntry represents a row entry from the migration schema history table.
type migrationEntry struct {
	// Version is the unix timestamp in seconds, at which this migration was defined.
	Version int64
	// File is the file path indicating the origin of the statements.
	File string
	// Line is the line number indicating the origin of the statements.
	Line int32
	// Checksum is the hex encoded first 16 byte sha3-256 checksum of all trimmed statements.
	Checksum string
	// AppliedAt is the unix timestamp in seconds when this migration has been applied.
	AppliedAt int64
	// ExecutionDuration is the amount of nanoseconds which were needed to apply this migration.
	ExecutionDuration int64
}

// String serializes the struct into a json string.
func (m migrationEntry) String() string {
	buf, err := json.Marshal(m)
	if err != nil {
		panic("invalid state: " + err.Error())
	}

	return string(buf)
}

// readMigrationHistoryTable reads the entire history into memory, which are only a few bytes.
func readMigrationHistoryTable(db DBTX) ([]migrationEntry, error) {
	var res []migrationEntry
	rows, err := db.QueryContext(context.Background(), "SELECT * FROM search_migration_schema_history ORDER BY version ASC")
	if err != nil {
		return nil, fmt.Errorf("cannot query history: %w", err)
	}
	defer rows.Close()
	for rows.Next() {
		var i migrationEntry
		if err := rows.Scan(&i.Version, &i.File, &i.Line, &i.Checksum, &i.AppliedAt, &i.ExecutionDuration); err != nil {
			return nil, fmt.Errorf("scan failed: %w", err)
		}
		res = append(res, i)
	}
	err = rows.Close()
	if err != nil {
		return res, fmt.Errorf("cannot close rows: %w", err)
	}

	err = rows.Err()
	if err != nil {
		return res, fmt.Errorf("query failed: %w", err)
	}

	return res, nil
}

// insertMigrationEntry writes a migration entry into the history table.
func insertMigrationEntry(db DBTX, entry migrationEntry) error {
	const q = "INSERT INTO search_migration_schema_history(version, file, line, checksum, applied_at, execution_duration) VALUES (?, ?, ?, ?, ?, ?)"
	_, err := db.ExecContext(context.Background(), q, entry.Version, entry.File, entry.Line, entry.Checksum, entry.AppliedAt, entry.ExecutionDuration)
	if err != nil {
		return fmt.Errorf("cannot ExecContext: %w", err)
	}

	return nil
}

// Migrate ensures that the migration history table exists, checks the checksums of all already applied migrations
// and applies all missing migrations in the defined version order.
func Migrate(db DBTX) error {

	// if we can start a transaction on our own, do so and invoke recursively
	if db, ok := db.(*sql.DB); ok {
		tx, err := db.BeginTx(context.Background(), nil)
		if err != nil {
			return fmt.Errorf("cannot begin transaction: %w", err)
		}

		if err := Migrate(tx); err != nil {
			if suppressedErr := tx.Rollback(); suppressedErr != nil {
				fmt.Println(suppressedErr.Error())
			}
			return err
		}

		if err := tx.Commit(); err != nil {
			return err
		}

		return nil
	}

	const q = `CREATE TABLE IF NOT EXISTS "search_migration_schema_history"
(
    "version"            BIGINT       NOT NULL,
    "file"               VARCHAR(255) NOT NULL,
    "line"               INT          NOT NULL,
    "checksum"           CHAR(32)     NOT NULL,
    "applied_at"         TIMESTAMP    NOT NULL,
    "execution_duration" BIGINT       NOT NULL,
    PRIMARY KEY ("version")
)`
	if _, err := db.ExecContext(context.Background(), q); err != nil {
		return fmt.Errorf("cannot create search_migration_schema_history: %w", err)
	}

	history, err := readMigrationHistoryTable(db)
	if err != nil {
		return fmt.Errorf("cannot read history: %w", err)
	}

	availMigrations := migrations()

	// check history validity:
	// 1. is everything which has been applied still defined?
	// 2. has any checksum changed?
	for _, entry := range history {
		found := false
		for _, m := range availMigrations {
			if entry.Version == m.Version {
				if entry.Checksum != m.Checksum {
					return fmt.Errorf("already applied migration %s has been modified. Expected %s but found %s", entry.String(), entry.Checksum, m.Checksum)
				}

				found = true
				break
			}
		}

		if !found {
			return fmt.Errorf("already applied migration %s is undefined", entry.String())
		}
	}

	// pick migrations to apply
	for _, m := range availMigrations {
		alreadyApplied := false
		for _, entry := range history {
			if m.Version == entry.Version {
				alreadyApplied = true
				break
			}
		}

		if !alreadyApplied {
			start := time.Now()
			err := m.Apply(db)
			if err != nil {
				return fmt.Errorf("unable to apply migration %s: %w", m.String(), err)
			}
			duration := time.Now().Sub(start)
			err = insertMigrationEntry(db, migrationEntry{
				Version:           m.Version,
				File:              m.File,
				Line:              m.Line,
				Checksum:          m.Checksum,
				AppliedAt:         start.Unix(),
				ExecutionDuration: duration.Nanoseconds(),
			})

			if err != nil {
				return fmt.Errorf("unable to persist migration state %s: %w", m.String(), err)
			}
		}
	}

	return nil
}

// migrations returns all available migrations in sorted order from oldest to latest.
func migrations() []migration {
	return []migration{
		{
			Version:  1600256820, // 2020-09-16T11:47:00
			File:     "architecture.go",
			Line:     108,
			Checksum: "e93111049a17c9e27a2aeebfd6e57210",
			Statements: []string{
				"CREATE TABLE book (`id` BINARY(16), name VARCHAR(255))",
				"CREATE TABLE book3 (id BINARY(16))",
			},
		},
		{
			Version:  1600343220, // 2020-09-17T11:47:00
			File:     "architecture.go",
			Line:     114,
			Checksum: "7a78a1f10776298895bda4accd08087c",
			Statements: []string{
				"CREATE TABLE book2 (id BINARY(16), name VARCHAR(255))",
			},
		},
	}
}
