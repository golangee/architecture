// Code generated by golangee/architecture. DO NOT EDIT.

// Package mysql contains specific repository implementations (aka SPI or driven adapter) for the mysql dialect.
// The repository is defined at the core layer (aka domain API).
package mysql

import (
	context "context"
	sql "database/sql"
	json "encoding/json"
	flag "flag"
	fmt "fmt"
	_ "github.com/go-sql-driver/mysql"
	url "net/url"
	os "os"
	strconv "strconv"
	strings "strings"
	time "time"
)

// DBTX abstracts from a concrete sql.DB or sql.Tx dependency.
type DBTX interface {
	// ExecContext represents an according call to sql.DB or sql.Tx
	ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
	// QueryContext represents an according call to sql.DB or sql.Tx
	QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
}

// Options contains the connection options for a MySQL database.
type Options struct {
	// Port is the database port to connect.
	Port int64 `json:"port,omitempty"`
	// User is the database user.
	User string `json:"user,omitempty"`
	// Password is the database user password.
	Password string `json:"password,omitempty"`
	// Protocol is the protocol to use.
	Protocol string `json:"protocol,omitempty"`
	// Database is the database name.
	Database string `json:"database,omitempty"`
	// Address is the host or path to socket.
	Address string `json:"address,omitempty"`
	// Collation declares the connections default collation for sorting and indexing.
	Collation string `json:"collation,omitempty"`
	// Charset declares the connections default charset encoding for text.
	Charset string `json:"charset,omitempty"`
	// MaxAllowedPacket is the max packet size in bytes.
	MaxAllowedPacket int64 `json:"maxAllowedPacket,omitempty"`
	// Timeout is the duration until the dial receives a timeout.
	Timeout time.Duration `json:"timeout,omitempty"`
	// WriteTimeout is the duration for the write timeout.
	WriteTimeout time.Duration `json:"writeTimeout,omitempty"`
	// Tls configures connection security. Valid values are true, false, skip-verify or preferred.
	Tls string `json:"tls,omitempty"`
	// SqlMode is a flag which influences the sql parser.
	SqlMode string `json:"sqlMode,omitempty"`
	// ConnMaxLifetime is the duration of how long pooled connections are kept alive.
	ConnMaxLifetime time.Duration `json:"connMaxLifetime,omitempty"`
	// MaxOpenConns is the amount of how many open connections can be kept in the pool.
	MaxOpenConns int64 `json:"maxOpenConns,omitempty"`
	// MaxIdleConns is the amount of how many open connections can be idle.
	MaxIdleConns int64 `json:"maxIdleConns,omitempty"`
}

// Reset restores this instance to the default state.
//  * The default value of Port is '3306'.
//  * The default value of User is '"root"'.
//  * The default value of Password is ''.
//  * The default value of Protocol is '"tcp"'.
//  * The default value of Database is '"booklibrary"'.
//  * The default value of Address is '"localhost"'.
//  * The default value of Collation is '"utf8mb4_unicode_520_ci"'.
//  * The default value of Charset is '"utf8mb4"'.
//  * The default value of MaxAllowedPacket is '4194304'.
//  * The default value of Timeout is '30s'.
//  * The default value of WriteTimeout is '30s'.
//  * The default value of Tls is '"false"'.
//  * The default value of SqlMode is '"ANSI"'.
//  * The default value of ConnMaxLifetime is '3m'.
//  * The default value of MaxOpenConns is '25'.
//  * The default value of MaxIdleConns is '25'.
func (o *Options) Reset() {
	o.Port = 3306
	o.User = "root"
	o.Password = ""
	o.Protocol = "tcp"
	o.Database = "booklibrary"
	o.Address = "localhost"
	o.Collation = "utf8mb4_unicode_520_ci"
	o.Charset = "utf8mb4"
	o.MaxAllowedPacket = 4194304
	o.Timeout = time.Duration(30000000000)      // 30s
	o.WriteTimeout = time.Duration(30000000000) // 30s
	o.Tls = "false"
	o.SqlMode = "ANSI"
	o.ConnMaxLifetime = time.Duration(180000000000) // 3m
	o.MaxOpenConns = 25
	o.MaxIdleConns = 25
}

// ParseEnv tries to parse the environment variables into this instance. It will only set those values, which have been actually defined. If values cannot be parsed, an error is returned.
//  * Port is parsed from flag 'MYSQL_SEARCH_PORT'
//  * User is parsed from flag 'MYSQL_SEARCH_USER'
//  * Password is parsed from flag 'MYSQL_SEARCH_PASSWORD'
//  * Protocol is parsed from flag 'MYSQL_SEARCH_PROTOCOL'
//  * Database is parsed from flag 'MYSQL_SEARCH_DATABASE'
//  * Address is parsed from flag 'MYSQL_SEARCH_ADDRESS'
//  * Collation is parsed from flag 'MYSQL_SEARCH_COLLATION'
//  * Charset is parsed from flag 'MYSQL_SEARCH_CHARSET'
//  * MaxAllowedPacket is parsed from flag 'MYSQL_SEARCH_MAXALLOWEDPACKET'
//  * Timeout is parsed from flag 'MYSQL_SEARCH_TIMEOUT'
//  * WriteTimeout is parsed from flag 'MYSQL_SEARCH_WRITETIMEOUT'
//  * Tls is parsed from flag 'MYSQL_SEARCH_TLS'
//  * SqlMode is parsed from flag 'MYSQL_SEARCH_SQLMODE'
//  * ConnMaxLifetime is parsed from flag 'MYSQL_SEARCH_CONNMAXLIFETIME'
//  * MaxOpenConns is parsed from flag 'MYSQL_SEARCH_MAXOPENCONNS'
//  * MaxIdleConns is parsed from flag 'MYSQL_SEARCH_MAXIDLECONNS'
func (o *Options) ParseEnv() error {
	if value, ok := os.LookupEnv("MYSQL_SEARCH_PORT"); ok {
		v, err := strconv.ParseInt(value, 10, 64)
		if err != nil {
			return fmt.Errorf("cannot parse environment variable 'MYSQL_SEARCH_PORT': %w", err)
		}

		o.Port = v
	}

	if value, ok := os.LookupEnv("MYSQL_SEARCH_USER"); ok {
		o.User = value
	}

	if value, ok := os.LookupEnv("MYSQL_SEARCH_PASSWORD"); ok {
		o.Password = value
	}

	if value, ok := os.LookupEnv("MYSQL_SEARCH_PROTOCOL"); ok {
		o.Protocol = value
	}

	if value, ok := os.LookupEnv("MYSQL_SEARCH_DATABASE"); ok {
		o.Database = value
	}

	if value, ok := os.LookupEnv("MYSQL_SEARCH_ADDRESS"); ok {
		o.Address = value
	}

	if value, ok := os.LookupEnv("MYSQL_SEARCH_COLLATION"); ok {
		o.Collation = value
	}

	if value, ok := os.LookupEnv("MYSQL_SEARCH_CHARSET"); ok {
		o.Charset = value
	}

	if value, ok := os.LookupEnv("MYSQL_SEARCH_MAXALLOWEDPACKET"); ok {
		v, err := strconv.ParseInt(value, 10, 64)
		if err != nil {
			return fmt.Errorf("cannot parse environment variable 'MYSQL_SEARCH_MAXALLOWEDPACKET': %w", err)
		}

		o.MaxAllowedPacket = v
	}

	if value, ok := os.LookupEnv("MYSQL_SEARCH_TIMEOUT"); ok {
		v, err := time.ParseDuration(value)
		if err != nil {
			return fmt.Errorf("cannot parse environment variable 'MYSQL_SEARCH_TIMEOUT': %w", err)
		}

		o.Timeout = v
	}

	if value, ok := os.LookupEnv("MYSQL_SEARCH_WRITETIMEOUT"); ok {
		v, err := time.ParseDuration(value)
		if err != nil {
			return fmt.Errorf("cannot parse environment variable 'MYSQL_SEARCH_WRITETIMEOUT': %w", err)
		}

		o.WriteTimeout = v
	}

	if value, ok := os.LookupEnv("MYSQL_SEARCH_TLS"); ok {
		o.Tls = value
	}

	if value, ok := os.LookupEnv("MYSQL_SEARCH_SQLMODE"); ok {
		o.SqlMode = value
	}

	if value, ok := os.LookupEnv("MYSQL_SEARCH_CONNMAXLIFETIME"); ok {
		v, err := time.ParseDuration(value)
		if err != nil {
			return fmt.Errorf("cannot parse environment variable 'MYSQL_SEARCH_CONNMAXLIFETIME': %w", err)
		}

		o.ConnMaxLifetime = v
	}

	if value, ok := os.LookupEnv("MYSQL_SEARCH_MAXOPENCONNS"); ok {
		v, err := strconv.ParseInt(value, 10, 64)
		if err != nil {
			return fmt.Errorf("cannot parse environment variable 'MYSQL_SEARCH_MAXOPENCONNS': %w", err)
		}

		o.MaxOpenConns = v
	}

	if value, ok := os.LookupEnv("MYSQL_SEARCH_MAXIDLECONNS"); ok {
		v, err := strconv.ParseInt(value, 10, 64)
		if err != nil {
			return fmt.Errorf("cannot parse environment variable 'MYSQL_SEARCH_MAXIDLECONNS': %w", err)
		}

		o.MaxIdleConns = v
	}

	return nil
}

// ConfigureFlags configures the flags to be ready to get evaluated. The default values are taken from the struct at calling time.
// After calling, use flag.Parse() to load the values. You can only use it once, otherwise the flag package will panic.
// The following flags will be tied to this instance:
//  * Port is parsed from flag 'mysql-search-port'
//  * User is parsed from flag 'mysql-search-user'
//  * Password is parsed from flag 'mysql-search-password'
//  * Protocol is parsed from flag 'mysql-search-protocol'
//  * Database is parsed from flag 'mysql-search-database'
//  * Address is parsed from flag 'mysql-search-address'
//  * Collation is parsed from flag 'mysql-search-collation'
//  * Charset is parsed from flag 'mysql-search-charset'
//  * MaxAllowedPacket is parsed from flag 'mysql-search-maxallowedpacket'
//  * Timeout is parsed from flag 'mysql-search-timeout'
//  * WriteTimeout is parsed from flag 'mysql-search-writetimeout'
//  * Tls is parsed from flag 'mysql-search-tls'
//  * SqlMode is parsed from flag 'mysql-search-sqlmode'
//  * ConnMaxLifetime is parsed from flag 'mysql-search-connmaxlifetime'
//  * MaxOpenConns is parsed from flag 'mysql-search-maxopenconns'
//  * MaxIdleConns is parsed from flag 'mysql-search-maxidleconns'
func (o *Options) ConfigureFlags() {
	flag.Int64Var(&o.Port, "mysql-search-port", o.Port, "Port is the database port to connect.")
	flag.StringVar(&o.User, "mysql-search-user", o.User, "User is the database user.")
	flag.StringVar(&o.Password, "mysql-search-password", o.Password, "Password is the database user password.")
	flag.StringVar(&o.Protocol, "mysql-search-protocol", o.Protocol, "Protocol is the protocol to use.")
	flag.StringVar(&o.Database, "mysql-search-database", o.Database, "Database is the database name.")
	flag.StringVar(&o.Address, "mysql-search-address", o.Address, "Address is the host or path to socket.")
	flag.StringVar(&o.Collation, "mysql-search-collation", o.Collation, "Collation declares the connections default collation for sorting and indexing.")
	flag.StringVar(&o.Charset, "mysql-search-charset", o.Charset, "Charset declares the connections default charset encoding for text.")
	flag.Int64Var(&o.MaxAllowedPacket, "mysql-search-maxallowedpacket", o.MaxAllowedPacket, "MaxAllowedPacket is the max packet size in bytes.")
	flag.DurationVar(&o.Timeout, "mysql-search-timeout", o.Timeout, "Timeout is the duration until the dial receives a timeout.")
	flag.DurationVar(&o.WriteTimeout, "mysql-search-writetimeout", o.WriteTimeout, "WriteTimeout is the duration for the write timeout.")
	flag.StringVar(&o.Tls, "mysql-search-tls", o.Tls, "Tls configures connection security. Valid values are true, false, skip-verify or preferred.")
	flag.StringVar(&o.SqlMode, "mysql-search-sqlmode", o.SqlMode, "SqlMode is a flag which influences the sql parser.")
	flag.DurationVar(&o.ConnMaxLifetime, "mysql-search-connmaxlifetime", o.ConnMaxLifetime, "ConnMaxLifetime is the duration of how long pooled connections are kept alive.")
	flag.Int64Var(&o.MaxOpenConns, "mysql-search-maxopenconns", o.MaxOpenConns, "MaxOpenConns is the amount of how many open connections can be kept in the pool.")
	flag.Int64Var(&o.MaxIdleConns, "mysql-search-maxidleconns", o.MaxIdleConns, "MaxIdleConns is the amount of how many open connections can be idle.")
}

// String serializes the struct into a json string.
func (o *Options) String() string {
	buf, err := json.Marshal(o)
	if err != nil {
		panic("invalid state: " + err.Error())
	}

	return string(buf)
}

// Parse tries to parse the given buffer as json and updates the current values accordingly.
func (o *Options) Parse(buf []byte) error {
	if err := json.Unmarshal(buf, o); err != nil {
		return err
	}

	return nil
}

// DSN returns the options as a fully serialized datasource name.
// The returned string is of the form:
//   username:password@protocol(address)/dbname?param=value
func (o *Options) DSN() string {
	sb := &strings.Builder{}
	sb.WriteString(url.PathEscape(o.User))
	sb.WriteString(":")
	sb.WriteString(url.PathEscape(o.Password))
	sb.WriteString("@")
	sb.WriteString(o.Protocol)
	sb.WriteString("(")
	sb.WriteString(o.Address)
	sb.WriteString(")")
	sb.WriteString("/")
	sb.WriteString(o.Database)
	sb.WriteString("?")
	sb.WriteString(fmt.Sprintf("%s=%s&", "collation", url.QueryEscape(o.Collation)))
	sb.WriteString(fmt.Sprintf("%s=%v&", "maxAllowedPacket", o.MaxAllowedPacket))
	sb.WriteString(fmt.Sprintf("%s=%s&", "tls", url.QueryEscape(o.Tls)))
	sb.WriteString(fmt.Sprintf("%s=%v&", "timeout", o.Timeout))
	sb.WriteString(fmt.Sprintf("%s=%v&", "writeTimeout", o.WriteTimeout))
	sb.WriteString(fmt.Sprintf("%s=%s&", "sql_mode", url.QueryEscape(o.SqlMode)))
	sb.WriteString(fmt.Sprintf("%s=%s&", "charset", url.QueryEscape(o.Charset)))
	return sb.String()
}

// Open tries to connect to a mysql compatible database.
func Open(opts Options) (DBTX, error) {
	db, err := sql.Open("mysql", opts.DSN())
	if err != nil {
		return nil, fmt.Errorf("cannot open database: %w", err)
	}

	err = db.Ping()
	if err != nil {
		return nil, fmt.Errorf("cannot ping database: %w", err)
	}

	db.SetConnMaxLifetime(opts.ConnMaxLifetime)
	db.SetMaxOpenConns(int(opts.MaxOpenConns))
	db.SetMaxIdleConns(int(opts.MaxIdleConns))
	return db, nil
}
